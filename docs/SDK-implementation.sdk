# SDK Implementation Checklist

Copy this checklist to each SDK repository and check off tasks as they're completed.

## Ideal Component Structure

Maintain consistent naming across languages where possible:

```
{language}-sdk/
├── public-api/
│   ├── Client (facade + constructor)
│   ├── Config (configuration structure)
│   └── Types (events, logs, enums, errors)
├── internal/
│   ├── api/
│   │   ├── client (internal coordination)
│   │   ├── events (event protocol handlers)
│   │   ├── logs (log protocol handlers)
│   │   └── stats (metrics aggregation)
│   ├── batch/
│   │   └── manager (generic batching logic)
│   ├── transport/
│   │   ├── connection (TCP management)
│   │   ├── sender (frame + protocol)
│   │   └── types (internal transport types)
│   ├── convert/
│   │   ├── events (public → internal conversion)
│   │   └── logs (public → internal conversion)
│   ├── protocol/
│   │   └── flatbuffers (schema + serialization)
│   └── utils/
│       ├── logger (debug logging)
│       ├── validation (input validation)
│       └── version (version info)
└── schema/ (shared FlatBuffers files)
    ├── common.fbs
    ├── event.fbs
    └── log.fbs
```

## Core Components

### Client Facade (Public API)
- [ ] `NewClient(apiKey, config)` constructor with API key validation
- [ ] State management (active/closing/closed)
- [ ] `Close()` method with graceful shutdown and final flush
- [ ] Error handling with language-appropriate error types
- [ ] `GetStats()` method for observability
- [ ] `DumpStatus()` method for debugging

### Internal Client (Coordination)
- [ ] Component lifecycle management (start/stop batchers)
- [ ] Dual batch manager coordination (separate events + logs)
- [ ] Configuration distribution to all components
- [ ] `Flush()` method coordinating both batchers
- [ ] Thread-safe state checking (`checkClosed()`)

### Batch Manager (Generic)
- [ ] Generic batching for any item type (`interface{}` / `any` / `AnyObject`)
- [ ] Size-based batching trigger (configurable, default: 100)
- [ ] Time-based periodic flushing (configurable, default: 10s)
- [ ] Thread-safe queue operations (mutex/locks)
- [ ] Retry logic with item re-queuing on network failure
- [ ] Statistics tracking (success/failure counts, timing)

### Transport Layer
- [ ] TCP connection establishment and persistent management
- [ ] TLS support for production endpoints
- [ ] Exponential backoff retry logic (1s → 30s max)
- [ ] Connection health monitoring with reconnection
- [ ] Message framing (4-byte length prefix + payload)
- [ ] DNS failover support (multiple IP resolution)

### Binary Protocol Handler
- [ ] FlatBuffers schema compilation (generate from .fbs files)
- [ ] Event batch serialization (Batch → EventData)
- [ ] Log batch serialization (Batch → LogData)
- [ ] Batch header with API key authentication + batch ID
- [ ] Property map serialization (mixed value types → JSON bytes)
- [ ] Size validation (max 10MB batch, 1000 items)

## Event Analytics API

### Basic Event Tracking
- [ ] `Track(event)` method with context parameter
- [ ] Event validation (user_id, event_name required, non-empty)
- [ ] Properties map supporting string/int/float/bool/null values
- [ ] Automatic timestamp if not provided (`time.Now()`)
- [ ] Event ID generation if missing

### Advanced Event Features
- [ ] `Identify(identity)` for user traits (EventType: IDENTIFY)
- [ ] `Group(groupInfo)` for group associations (EventType: GROUP)
- [ ] `Revenue(revenue)` with products array (EventType: TRACK)
- [ ] Standard event name constants (UserSignedUp, FeatureUsed, OrderCompleted, etc.)
- [ ] Currency enum (USD, EUR, GBP)
- [ ] Revenue type enum (subscription, one_time)

## Structured Logging API

### Basic Logging
- [ ] `Log(logEntry)` method with full LogEntry structure
- [ ] Log level validation (0-8 syslog levels: Emergency → Trace)
- [ ] Required fields validation (service, source required)
- [ ] Message + structured data support
- [ ] Automatic timestamp if not provided

### Advanced Logging Features
- [ ] `LogInfo()`, `LogError()`, `LogDebug()` convenience methods
- [ ] `LogBatch(entries)` for bulk logging operations
- [ ] Context ID for distributed tracing correlation
- [ ] Event type routing (LogCollect/LogEnrich/LogAuth)
- [ ] Service and source identification

## Configuration & Operations

### Configuration Management
- [ ] Default configuration values (endpoint: collect.usercanal.com:50000, batchSize: 100, flushInterval: 10s, maxRetries: 3, debug: false)
- [ ] Option pattern or builder pattern for config override
- [ ] Configuration validation (positive numbers, valid endpoints)

### Operations & Observability
- [ ] `GetStats()` returning queue sizes, success/failure counts, connection state
- [ ] Debug logging system (configurable on/off)
- [ ] Proper error types (ValidationError, NetworkError, TimeoutError)
- [ ] Input validation for all public methods with descriptive error messages

## Data Type System

### Core Types
- [ ] `Properties` map type (string → mixed values)
- [ ] `Event` struct (UserId, Name, Properties, Timestamp)
- [ ] `Identity` struct (UserId, Properties)
- [ ] `GroupInfo` struct (UserId, GroupId, Properties)
- [ ] `Revenue` struct (UserID, OrderID, Amount, Currency, Type, Products)
- [ ] `Product` struct (ID, Name, Price, Quantity)
- [ ] `LogEntry` struct (Level, Service, Source, Message, Data, EventType)

### Enums & Constants
- [ ] `EventName` enum with standard constants
- [ ] `Currency` enum (USD, EUR, GBP)
- [ ] `RevenueType` enum (subscription, one_time)
- [ ] `LogLevel` enum (0-8 syslog levels)
- [ ] `LogEventType` enum (Collect, Enrich, Auth)

### Error Types
- [ ] `ValidationError` (field-specific validation failures)
- [ ] `NetworkError` (connection, send failures)
- [ ] `TimeoutError` (context cancellation, deadlines)

## Examples & Integration

### Event Examples
- [ ] Simple tracking example (Track with properties)
- [ ] Advanced example (Identify + Group + Revenue with products)
- [ ] Standard event types usage demonstration

### Logging Examples
- [ ] Simple structured logging (LogInfo with data)
- [ ] Advanced example (context correlation + bulk logging)
- [ ] Service identification patterns

### Integration Patterns
- [ ] Basic setup and graceful shutdown
- [ ] Error handling and retry patterns
- [ ] High-throughput usage patterns

---

**Implementation Priority:**
1. **Core Components** (Client Facade → Internal Client → Batch Manager)
2. **Basic APIs** (Track, Log methods with validation)
3. **Transport Layer** (TCP + FlatBuffers)
4. **Advanced Features** (Revenue, Identity, convenience methods)
